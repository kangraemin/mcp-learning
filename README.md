# TIL 지식 관리 MCP 서버

개발 학습 내용(TIL: Today I Learned)을 기록하고, 검색하고, 요약해주는 서버.
Claude에게 "오늘 배운 거 기록해줘"라고 말하면 알아서 저장해준다.

---

## MCP가 뭔데?

MCP(Model Context Protocol)는 **AI가 외부 도구를 사용하기 위한 약속(프로토콜)**이다.

평소 Claude는 대화만 할 수 있다. 파일을 저장하거나, 데이터베이스를 조회하거나, API를 호출하는 건 못 한다. MCP 서버를 연결하면 Claude가 이런 **행동**을 할 수 있게 된다.

비유하자면:

```
평소 Claude = 말만 할 수 있는 사람
MCP 서버    = 그 사람에게 주는 도구 (펜, 계산기, 노트 등)
MCP 프로토콜 = "펜 줘" → 펜을 건네주는 방법에 대한 약속
```

---

## 이 프로젝트는 뭘 하는 거야?

Claude에게 **"TIL 노트"라는 도구**를 주는 것이다.

이 서버를 설치하면 Claude가 할 수 있는 일:

| 말하면 | Claude가 하는 일 |
|--------|-----------------|
| "오늘 Python 배운 거 기록해줘" | TIL을 작성해서 데이터베이스에 저장 |
| "지난주에 뭐 배웠지?" | 데이터베이스에서 지난주 기록을 꺼내서 보여줌 |
| "MCP 관련 기록 찾아줘" | 키워드로 검색해서 결과를 보여줌 |
| "이번 주 학습 회고 써줘" | 이번 주 기록을 분석해서 회고문을 작성 |
| "기록 삭제해줘" | 데이터베이스에서 해당 기록을 삭제 |

사용자는 자연어로 말하기만 하면 된다. 나머지는 Claude와 이 서버가 알아서 처리한다.

---

## 어떤 원리로 동작해?

### 전체 그림

```
사용자: "Python 데코레이터 배운 거 기록해줘"
    │
    │  ① 사용자가 말한다
    ▼
┌──────────────┐
│ Claude Code  │  ← 우리가 쓰는 프로그램 (터미널 앱)
└──────┬───────┘
       │  ② 인터넷으로 Claude AI에게 물어본다
       ▼
┌──────────────┐
│ Claude (AI)  │  ← Anthropic 서버에서 돌아가는 AI
│              │     "기록해달라고 했으니 create_til을 써야겠다"
└──────┬───────┘
       │  ③ "create_til 도구를 써줘"라고 답한다
       ▼
┌──────────────┐
│ Claude Code  │  ← 이 답을 받아서 MCP 서버에 전달
└──────┬───────┘
       │  ④ 로컬 컴퓨터 안에서 서버에게 전달
       ▼
┌──────────────┐
│ TIL MCP 서버 │  ← 이 프로젝트! 내 컴퓨터에서 돌아감
│  (server.py) │
└──────┬───────┘
       │  ⑤ 데이터베이스에 저장
       ▼
┌──────────────┐
│   SQLite DB  │  ← data/til.db 파일
│  (til.db)    │     내 컴퓨터의 파일 하나
└──────────────┘
```

### 단계별 설명

**① 사용자가 말한다**

터미널에서 Claude Code를 열고 자연어로 말한다. 프로그래밍 명령어 같은 건 필요 없다.

```
> Python 데코레이터 배운 거 기록해줘
```

**② Claude Code가 AI에게 물어본다**

Claude Code는 이 말을 인터넷을 통해 Claude AI에게 보낸다. 이때 "너한테는 이런 도구들이 있어"라는 목록도 함께 보낸다:

```
[Claude AI가 받는 정보]
사용자 메시지: "Python 데코레이터 배운 거 기록해줘"
사용 가능한 도구:
  - create_til: TIL을 새로 만든다 (제목, 내용, 태그 필요)
  - search_til: TIL을 검색한다 (검색어 필요)
  - delete_til: TIL을 삭제한다 (ID 필요)
  - ... 등등
```

**③ Claude AI가 판단한다**

Claude AI는 사람의 말을 이해하고, 어떤 도구를 써야 할지 **스스로 판단**한다:

> "사용자가 '기록해줘'라고 했다"
> "→ 새로 만드는 거니까 create_til을 써야겠다"
> "→ 제목은 'Python 데코레이터', 태그는 ['python']이 적절하겠다"

그리고 이렇게 답한다:

```
"create_til 도구를 써줘.
 제목: Python 데코레이터의 동작 원리
 내용: 데코레이터는 함수를 감싸서...
 태그: python, decorator"
```

**중요**: Claude AI는 코드를 직접 실행하지 않는다. "이 도구를 이 값으로 써줘"라고 **요청만** 한다.

**④ Claude Code가 MCP 서버에게 전달한다**

Claude Code가 이 요청을 받아서, 내 컴퓨터에서 돌고 있는 MCP 서버에게 전달한다.

이 통신은 **인터넷을 안 탄다.** 내 컴퓨터 안에서 두 프로그램이 직접 대화하는 것이다. (자세한 원리는 아래 "서버와 대화하는 방법" 참고)

**⑤ MCP 서버가 실제로 저장한다**

서버가 Python 코드를 실행해서 SQLite 데이터베이스에 실제로 데이터를 저장한다:

```sql
INSERT INTO tils (title, content, category)
VALUES ('Python 데코레이터의 동작 원리', '데코레이터는...', 'python');
```

저장이 끝나면 결과를 Claude Code → Claude AI → 사용자 순서로 돌려보낸다.

사용자가 보는 최종 답변:

```
Python 데코레이터에 대한 TIL을 기록했습니다!
- ID: 1
- 제목: Python 데코레이터의 동작 원리
- 태그: python, decorator
```

---

## Claude Code와 MCP 서버는 어떻게 대화해?

### stdin/stdout이란?

모든 프로그램에는 **입구**와 **출구**가 있다.

- **stdin (표준 입력)** = 입구. 평소에는 키보드에 연결되어 있다.
- **stdout (표준 출력)** = 출구. 평소에는 화면에 연결되어 있다.

```
[평소 프로그램]
키보드 → (입구/stdin) → 프로그램 → (출구/stdout) → 화면
```

### 파이프: 입구/출구를 다른 프로그램에 연결

이 입구/출구를 화면이나 키보드 대신 **다른 프로그램**에 연결할 수 있다. 이걸 **파이프(pipe)**라고 한다.

터미널에서 `|` 기호를 본 적 있다면, 그게 파이프다:

```bash
echo "hello" | grep "hello"
#     ↑                ↑
#  echo의 출구를 grep의 입구에 연결
```

### MCP 서버도 같은 원리

Claude Code가 MCP 서버를 실행할 때, 서버의 입구/출구를 **자기한테 연결**한다:

```
[평소]
키보드 → 서버 → 화면

[MCP로 실행될 때]
Claude Code → 서버 → Claude Code
```

서버 화면에는 아무것도 안 나온다. 키보드 입력도 안 받는다. 오직 Claude Code하고만 대화한다.

대화 내용은 JSON이라는 형식의 텍스트다:

```
Claude Code가 보내는 메시지 (파이프를 통해 서버의 입구로):
  {"method": "tools/call", "params": {"name": "create_til", "arguments": {"title": "..."}}}

서버가 보내는 답변 (파이프를 통해 Claude Code에게):
  {"result": {"status": "created", "til": {"id": 1, "title": "..."}}}
```

사람이 읽기 어려운 형식이지만, 프로그램끼리는 이게 가장 효율적이다.

### 왜 이렇게 하는 거야?

MCP 서버가 **별도 프로그램**으로 돌아가기 때문에:

1. **Claude Code가 아닌 다른 AI 앱에서도 쓸 수 있다** (같은 약속/프로토콜만 지키면 됨)
2. **서버가 죽어도 Claude Code는 멀쩡하다** (서로 독립적)
3. **여러 MCP 서버를 동시에 연결할 수 있다** (TIL 서버 + 날씨 서버 + 캘린더 서버...)

---

## 서버 내부 구조

### 파일 구성

```
src/til_server/
├── server.py      # 서버의 메인. 모든 것을 조립하고 시작하는 곳
├── db.py          # 데이터베이스 담당. 실제로 데이터를 저장/조회
├── tools.py       # "행동" 6개 정의 (만들기, 수정, 삭제, 검색, 태그 추가, 내보내기)
├── resources.py   # "조회" 7개 정의 (목록, 오늘 것, 이번 주, 통계 등)
└── prompts.py     # "템플릿" 4개 정의 (작성 가이드, 주간 회고, 주제 추천, 요약)
```

### MCP의 3가지 도구 종류

MCP는 도구를 **세 종류**로 나눈다:

#### 1. Tool (도구) — "행동"하는 것

데이터를 **만들거나, 바꾸거나, 지우는** 기능이다. 식당 비유로는 **주방장**에게 내리는 명령이다.

| Tool 이름 | 하는 일 | 식당 비유 |
|-----------|---------|----------|
| `create_til` | 새 TIL 작성 | "새 메뉴 만들어줘" |
| `update_til` | TIL 수정 | "이 메뉴 레시피 바꿔줘" |
| `delete_til` | TIL 삭제 | "이 메뉴 없애줘" |
| `search_til` | TIL 검색 | "매운 메뉴 찾아줘" |
| `add_tag` | 태그 추가 | "이 메뉴에 '매운맛' 라벨 붙여줘" |
| `export_til` | Markdown 내보내기 | "메뉴판을 문서로 만들어줘" |

#### 2. Resource (자원) — "보여주는" 것

데이터를 **읽기만** 하는 기능이다. 식당 비유로는 **메뉴판을 보는** 것이다. 보기만 하고 바꾸지는 않는다.

| Resource | 하는 일 | 식당 비유 |
|----------|---------|----------|
| `til://list` | 전체 목록 | "메뉴판 전체 보여줘" |
| `til://list/today` | 오늘 작성한 것 | "오늘 새로 나온 메뉴" |
| `til://list/week` | 이번 주 작성한 것 | "이번 주 신메뉴" |
| `til://{id}` | 특정 TIL 상세 | "3번 메뉴 자세히" |
| `til://tags` | 태그 목록 | "라벨 목록" |
| `til://categories` | 카테고리 목록 | "카테고리 목록" |
| `til://stats` | 학습 통계 | "판매 통계" |

#### 3. Prompt (프롬프트) — "생각하는 방법"을 알려주는 것

Claude에게 **"이렇게 생각해"라는 지시서**를 미리 만들어두는 것이다. 식당 비유로는 **레시피 카드**이다.

| Prompt | 하는 일 |
|--------|---------|
| `write_til` | TIL 작성법을 알려줌 ("제목은 이렇게, 내용은 이렇게 써") |
| `weekly_review` | 주간 회고 작성법을 알려줌 + 이번 주 데이터를 함께 제공 |
| `suggest_topics` | 다음 학습 주제 추천법을 알려줌 + 기존 학습 이력 제공 |
| `summarize_learnings` | 기간별 학습 요약법을 알려줌 + 해당 기간 데이터 제공 |

### 왜 세 가지로 나눠?

```
Tool     = 주방 (요리를 만들고, 바꾸고, 버린다)
Resource = 메뉴판 (보기만 한다, 바꾸지 않는다)
Prompt   = 레시피 카드 (요리 방법을 알려준다)
```

이렇게 나누면 Claude가 **"지금 뭘 해야 하는지"** 더 정확하게 판단할 수 있다:
- "기록해줘" → 뭔가를 만들어야 한다 → Tool
- "뭐 있어?" → 보기만 하면 된다 → Resource
- "회고 써줘" → 생각하는 방법이 필요하다 → Prompt

---

## 데이터베이스 구조

모든 데이터는 `data/til.db` 파일 하나에 저장된다. SQLite라는 가벼운 데이터베이스를 사용하며, 별도 설치가 필요 없다.

### 테이블 3개

```
┌─────────────────────────────┐
│ tils (TIL 본문)              │
├─────────┬───────────────────┤
│ id      │ 1                 │
│ title   │ Python 데코레이터  │
│ content │ 함수를 감싸서...   │
│ category│ python            │
│ 작성일   │ 2026-02-21        │
└─────────┴───────────────────┘

┌─────────────────┐       ┌──────────────────────┐
│ tags (태그 목록)  │       │ til_tags (연결 테이블) │
├─────┬───────────┤       ├────────┬─────────────┤
│ id  │ name      │       │ til_id │ tag_id      │
│ 1   │ python    │       │ 1      │ 1 (python)  │
│ 2   │ decorator │       │ 1      │ 2 (decorator)│
└─────┴───────────┘       └────────┴─────────────┘
```

TIL 하나에 태그를 여러 개 달 수 있고, 같은 태그를 여러 TIL에 달 수 있다. 이걸 **다대다 관계**라고 한다. `til_tags` 테이블이 이 연결을 담당한다.

---

## 설치 및 실행

### 1. 의존성 설치

```bash
cd /Users/ram/programming/vibecoding/mcp
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

### 2. Claude Code에 MCP 서버 등록

```bash
claude mcp add --transport stdio til-server -- \
  /Users/ram/programming/vibecoding/mcp/venv/bin/python \
  -m til_server.server
```

### 3. 사용

Claude Code를 열고 자연어로 말하면 된다:

```
> 오늘 MCP 서버 만드는 법 배웠어. 기록해줘.
> 이번 주 뭐 배웠는지 보여줘
> python 태그 달린 거 검색해줘
> 주간 회고 써줘
```

---

## 기술 스택

| 항목 | 선택 | 설명 |
|------|------|------|
| 언어 | Python | 배우기 쉽고 MCP SDK가 잘 지원됨 |
| MCP 프레임워크 | FastMCP | `mcp` 패키지에 내장된 서버 프레임워크 |
| 데이터베이스 | SQLite | 설치 불필요, 파일 하나로 동작 |
| 전송 방식 | stdio | Claude Code와 가장 간편하게 연동 |

---

## 동작 흐름 요약

```
사용자가 말한다
    ↓
Claude Code가 인터넷으로 Claude AI에게 전달한다 (+ 도구 목록 포함)
    ↓
Claude AI가 어떤 도구를 쓸지 판단한다
    ↓
Claude Code가 로컬의 MCP 서버에 도구 호출을 전달한다 (파이프 통신)
    ↓
MCP 서버가 Python 함수를 실행하고 SQLite에 데이터를 저장/조회한다
    ↓
결과가 거꾸로 돌아간다: 서버 → Claude Code → Claude AI → 사용자
```

인터넷을 타는 구간: Claude Code ↔ Anthropic AI 서버
내 컴퓨터 안에서만 도는 구간: Claude Code ↔ MCP 서버 ↔ SQLite 파일
